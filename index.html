<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Xmas Tree (Icy) + Gold Ribbon + Hands</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#040512; }
    canvas { display:block; }
    #hud{
      position:fixed; left:12px; top:10px; z-index:20;
      color:rgba(210,220,255,.9);
      font:12px/1.5 system-ui, -apple-system, Segoe UI, Roboto;
      user-select:none; white-space:pre-wrap; max-width:82vw;
      text-shadow:0 0 12px rgba(90,160,255,.22);
    }
    #overlay{
      position:fixed; inset:0; z-index:30;
      display:flex; align-items:center; justify-content:center;
      background:radial-gradient(60% 60% at 50% 40%, rgba(20,30,80,.85), rgba(4,5,18,.97));
      color:rgba(235,240,255,.96);
      font:14px/1.6 system-ui;
      user-select:none;
    }
    #panel{
      width:min(660px, 92vw);
      border:1px solid rgba(120,150,255,.22);
      border-radius:14px;
      padding:18px 18px 14px;
      background:rgba(10,14,35,.58);
      box-shadow:0 10px 40px rgba(0,0,0,.35);
    }
    #row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    button{
      padding:10px 14px; border-radius:10px;
      border:1px solid rgba(140,170,255,.35);
      background:rgba(40,70,200,.25);
      color:rgba(245,248,255,.95);
      cursor:pointer;
    }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    button:hover{ background:rgba(40,70,200,.35); }
    #status{
      margin-top:10px; font-size:12px; opacity:.92;
      padding:10px; border-radius:10px;
      border:1px solid rgba(120,150,255,.18);
      background:rgba(0,0,0,.18);
      white-space:pre-wrap; word-break:break-word;
    }
    #cam{
      position:fixed; right:12px; bottom:12px; z-index:10;
      width:170px; aspect-ratio:4/3; border-radius:12px;
      border:1px solid rgba(120,150,255,.25);
      display:none; background:#000;
    }
  </style>
</head>

<body>
  <div id="hud"></div>

  <div id="overlay">
    <div id="panel">
      <div style="font-size:15px; margin-bottom:8px;">冰蓝圣诞树 + 金丝带 + 手势</div>
      <div>捏合（拇指+食指）：吸引</div>
      <div>张开（手掌打开）：爆炸</div>
      <div style="opacity:.85; margin-top:6px;">
        兜底触控：按住屏幕=吸引；松开=推开；双击=爆炸
      </div>

      <div id="row">
        <button id="btnCam">启动摄像头</button>
        <button id="btnHands" disabled>启动手势</button>
        <button id="btnGo" style="margin-left:auto;">进入画面</button>
      </div>

      <div id="status">状态：等待操作</div>
      <div style="opacity:.8; margin-top:8px; font-size:12px;">
        如果你必须开 VPN 才能访问页面，那就尽量选“全局/稳定节点”。手势启动失败时，看状态框最后几行就知道卡在哪。
      </div>
    </div>
  </div>

  <video id="cam" autoplay playsinline muted></video>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js";

    // ---------- UI ----------
    const hud = document.getElementById("hud");
    const overlay = document.getElementById("overlay");
    const statusBox = document.getElementById("status");
    const btnCam = document.getElementById("btnCam");
    const btnHands = document.getElementById("btnHands");
    const btnGo = document.getElementById("btnGo");
    const video = document.getElementById("cam");

    const setStatus = (s)=> statusBox.textContent = "状态： " + s;
    const addStatus = (s)=> statusBox.textContent += "\n" + s;

    function withTimeout(p, ms, label){
      return new Promise((resolve, reject)=>{
        const t = setTimeout(()=>reject(new Error(label + " timeout")), ms);
        p.then(v=>{ clearTimeout(t); resolve(v); }).catch(e=>{ clearTimeout(t); reject(e); });
      });
    }
    function loadScript(url){
      return new Promise((resolve, reject)=>{
        const s = document.createElement("script");
        s.src = url; s.crossOrigin = "anonymous";
        s.onload = ()=>resolve(true);
        s.onerror = ()=>reject(new Error("script load failed: " + url));
        document.head.appendChild(s);
      });
    }

    btnGo.addEventListener("click", ()=> overlay.style.display="none");

    // ---------- Scene ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x040512, 25, 120);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 260);
    camera.position.set(0, 18, 60);
    camera.lookAt(0, 9, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const point = new THREE.PointLight(0x88ccff, 1.2, 200);
    point.position.set(0, 30, 30);
    scene.add(point);

    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const rand = (a=1,b=0)=>b+Math.random()*(a-b);

    // ---------- Icy tree particles + Gold ribbon ----------
    const H = 34, BASE_R = 16;
    const MAIN = 19000, RIB = 5200, BELL = 220;
    const SNOW = 1400;

    function buildConePoint(){
      const y = rand(H/2, -H/2);
      const t = (y + H/2) / H;
      const r = (1 - t) * BASE_R * rand(1.06, 0.78);
      const rr = Math.sqrt(Math.random()) * r;
      const a = Math.random()*Math.PI*2;
      let x = Math.cos(a)*rr + rand(0.22, -0.22);
      let z = Math.sin(a)*rr + rand(0.22, -0.22);
      return {x,y,z,t};
    }

    function icyColor(t){
      // 更像你图里的冰蓝：底部偏蓝，顶部偏白亮
      const w = clamp(0.55 + (1-t)*0.18 + Math.random()*0.10, 0, 1);
      const r = clamp(0.40 + Math.random()*0.08 + (1-t)*0.10, 0, 1);
      const g = clamp(0.62 + Math.random()*0.10 + (1-t)*0.12, 0, 1);
      const b = clamp(0.92 + Math.random()*0.10 + (1-t)*0.06, 0, 1);
      // 混一点白
      return { r: r*(1-0.35)+w*0.35, g: g*(1-0.35)+w*0.35, b: b*(1-0.20)+w*0.20 };
    }

    function goldRibbonColor(){
      const r = 0.98;
      const g = 0.78 + Math.random()*0.10;
      const b = 0.18 + Math.random()*0.06;
      return {r,g,b};
    }

    function createPoints(count, size){
      const geom = new THREE.BufferGeometry();
      const pos  = new Float32Array(count*3);
      const col  = new Float32Array(count*3);
      const vel  = new Float32Array(count*3);
      const rest = new Float32Array(count*3);
      geom.setAttribute("position", new THREE.BufferAttribute(pos,3));
      geom.setAttribute("color", new THREE.BufferAttribute(col,3));

      const mat = new THREE.PointsMaterial({
        size,
        vertexColors:true,
        transparent:true,
        opacity:0.96,
        depthWrite:false,
        blending:THREE.AdditiveBlending
      });

      const pts = new THREE.Points(geom, mat);
      scene.add(pts);
      return {pts, geom, pos, col, vel, rest};
    }

    const main = createPoints(MAIN, 0.10);
    for(let i=0;i<MAIN;i++){
      const i3=i*3;
      const p=buildConePoint();
      const c=icyColor(p.t);
      main.pos[i3]=main.rest[i3]=p.x;
      main.pos[i3+1]=main.rest[i3+1]=p.y;
      main.pos[i3+2]=main.rest[i3+2]=p.z;
      main.col[i3]=c.r; main.col[i3+1]=c.g; main.col[i3+2]=c.b;
      main.vel[i3]=rand(0.008,-0.008); main.vel[i3+1]=rand(0.006,-0.006); main.vel[i3+2]=rand(0.008,-0.008);
    }

    // 金丝带：螺旋更明显一点
    const ribbon = createPoints(RIB, 0.14);
    const turns = 7.4;
    for(let i=0;i<RIB;i++){
      const i3=i*3;
      const t=i/(RIB-1);
      const y=-H/2+t*H;
      const radius=(1-t)*BASE_R*0.98;
      const a=t*turns*Math.PI*2 + (t>0.55?Math.PI*0.65:0);

      // 丝带厚度 + 轻微起伏
      const rJ = radius + rand(0.65, -0.65);
      const x = Math.cos(a)*rJ + rand(0.18,-0.18);
      const z = Math.sin(a)*rJ + rand(0.18,-0.18);

      const c = goldRibbonColor();
      ribbon.pos[i3]=ribbon.rest[i3]=x;
      ribbon.pos[i3+1]=ribbon.rest[i3+1]=y;
      ribbon.pos[i3+2]=ribbon.rest[i3+2]=z;
      ribbon.col[i3]=c.r; ribbon.col[i3+1]=c.g; ribbon.col[i3+2]=c.b;

      ribbon.vel[i3]=rand(0.007,-0.007); ribbon.vel[i3+1]=rand(0.006,-0.006); ribbon.vel[i3+2]=rand(0.007,-0.007);
    }

    // 小铃铛：点缀金白
    const bells = createPoints(BELL, 0.42);
    for(let i=0;i<BELL;i++){
      const i3=i*3;
      const levelT=[0.20,0.30,0.42,0.54,0.66,0.76][Math.floor(Math.random()*6)];
      const y=-H/2+levelT*H+rand(0.9,-0.9);
      const r=(1-levelT)*BASE_R*0.98;
      const a=Math.random()*Math.PI*2;
      const x=Math.cos(a)*(r+rand(0.8,0.2));
      const z=Math.sin(a)*(r+rand(0.8,0.2));
      const c={ r:1.0, g:0.86+Math.random()*0.08, b:0.35+Math.random()*0.06 };
      bells.pos[i3]=bells.rest[i3]=x;
      bells.pos[i3+1]=bells.rest[i3+1]=y;
      bells.pos[i3+2]=bells.rest[i3+2]=z;
      bells.col[i3]=c.r; bells.col[i3+1]=c.g; bells.col[i3+2]=c.b;
      bells.vel[i3]=rand(0.004,-0.004); bells.vel[i3+1]=rand(0.004,-0.004); bells.vel[i3+2]=rand(0.004,-0.004);
    }

    // 飘雪背景
    const snow = createPoints(SNOW, 0.08);
    for(let i=0;i<SNOW;i++){
      const i3=i*3;
      const x=rand(60,-60), y=rand(55,-5), z=rand(50,-50);
      snow.pos[i3]=snow.rest[i3]=x;
      snow.pos[i3+1]=snow.rest[i3+1]=y;
      snow.pos[i3+2]=snow.rest[i3+2]=z;
      const c={r:0.95,g:0.98,b:1.0};
      snow.col[i3]=c.r; snow.col[i3+1]=c.g; snow.col[i3+2]=c.b;
      snow.vel[i3]=0; snow.vel[i3+1]=rand(-0.06,-0.18); snow.vel[i3+2]=0;
    }

    // 顶部星芒（Sprite + 渐变纹理）
    function makeGlowTexture(){
      const c=document.createElement("canvas");
      c.width=c.height=256;
      const ctx=c.getContext("2d");
      const g=ctx.createRadialGradient(128,128,0,128,128,120);
      g.addColorStop(0, "rgba(255,255,255,1)");
      g.addColorStop(0.25, "rgba(180,230,255,0.95)");
      g.addColorStop(0.55, "rgba(120,190,255,0.55)");
      g.addColorStop(1, "rgba(80,140,255,0)");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,256,256);
      const tex=new THREE.CanvasTexture(c);
      tex.needsUpdate=true;
      return tex;
    }
    const glowMat = new THREE.SpriteMaterial({ map: makeGlowTexture(), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending });
    const glow = new THREE.Sprite(glowMat);
    glow.position.set(0, H/2 + 1.6, 0);
    glow.scale.set(18,18,1);
    scene.add(glow);

    // ---------- Input (touch/mouse + hands) ----------
    const pointerNDC = new THREE.Vector2(0,0);
    const pointerNDCSmooth = new THREE.Vector2(0,0);
    const pointerWorld = new THREE.Vector3(0,0,0);
    const raycaster = new THREE.Raycaster();
    const planeZ = new THREE.Plane(new THREE.Vector3(0,0,1), 0);

    let mouseDown=false;
    let usingHands=false;
    let gesture="touch/mouse";
    let pinch=NaN;
    let openScore=0;
    let explosion=0;
    let lastExplodeAt=0;

    function ndcFromClient(x,y){
      pointerNDC.x = (x/innerWidth)*2-1;
      pointerNDC.y = -(y/innerHeight)*2+1;
    }
    addEventListener("pointerdown",(e)=>{ if(usingHands) return; mouseDown=true; ndcFromClient(e.clientX,e.clientY); }, {passive:true});
    addEventListener("pointermove",(e)=>{ if(usingHands) return; ndcFromClient(e.clientX,e.clientY); }, {passive:true});
    addEventListener("pointerup",()=>{ if(usingHands) return; mouseDown=false; }, {passive:true});
    addEventListener("dblclick",()=>{
      const now=performance.now();
      if(now-lastExplodeAt>450){ explosion=1.0; lastExplodeAt=now; }
    });

    function updatePointerWorld(){
      pointerNDCSmooth.lerp(pointerNDC, 0.25);
      raycaster.setFromCamera(pointerNDCSmooth, camera);
      raycaster.ray.intersectPlane(planeZ, pointerWorld);
    }

    // ---------- Camera ----------
    async function startCam(){
      if(video.srcObject) return;
      setStatus("正在请求摄像头权限…");
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      addStatus("摄像头已开启");
    }

    // ---------- MediaPipe Hands (avoid Google Storage) ----------
    const HANDS_VER = "0.4.1675469240";
    const CAM_VER   = "0.3.1675466862";

    const SOURCES = [
      {
        name:"jsdelivr",
        handsJs:`https://cdn.jsdelivr.net/npm/@mediapipe/hands@${HANDS_VER}/hands.js`,
        camJs:`https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@${CAM_VER}/camera_utils.js`,
        handsBase:`https://cdn.jsdelivr.net/npm/@mediapipe/hands@${HANDS_VER}/`
      },
      {
        name:"unpkg",
        handsJs:`https://unpkg.com/@mediapipe/hands@${HANDS_VER}/hands.js`,
        camJs:`https://unpkg.com/@mediapipe/camera_utils@${CAM_VER}/camera_utils.js`,
        handsBase:`https://unpkg.com/@mediapipe/hands@${HANDS_VER}/`
      }
    ];

    let mpCamera=null;
    let hands=null;

    async function initHands(){
      if(hands) return;

      setStatus("加载手势库…");
      let chosen=null, lastErr=null;

      for(const s of SOURCES){
        try{
          addStatus(`尝试源：${s.name}`);
          await withTimeout(loadScript(s.handsJs), 12000, "hands.js");
          await withTimeout(loadScript(s.camJs), 12000, "camera_utils.js");
          chosen=s;
          addStatus("脚本加载成功：" + s.name);
          break;
        }catch(e){
          lastErr=e;
          addStatus("失败，换下一个源…");
        }
      }
      if(!chosen) throw (lastErr || new Error("手势脚本加载失败"));

      // 全局对象来自脚本：Hands / Camera
      hands = new Hands({
        locateFile: (file) => chosen.handsBase + file
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults((res)=>{
        const lm = res?.multiHandLandmarks?.[0];
        if(!lm){
          usingHands=false;
          gesture="touch/mouse";
          pinch=NaN;
          return;
        }
        usingHands=true;

        const wrist = lm[0];
        const indexTip = lm[8];
        const thumbTip = lm[4];

        pointerNDC.x = indexTip.x*2-1;
        pointerNDC.y = -(indexTip.y*2-1);

        pinch = Math.hypot(indexTip.x-thumbTip.x, indexTip.y-thumbTip.y);

        const tips = [lm[8], lm[12], lm[16], lm[20]];
        openScore = tips.reduce((a,p)=>a+Math.hypot(p.x-wrist.x, p.y-wrist.y), 0) / tips.length;

        const isPinch = pinch < 0.055;
        const isOpen  = openScore > 0.26 && pinch > 0.09;

        if(isPinch){
          gesture="pinch(attract)";
          mouseDown=true;
        }else{
          mouseDown=false;
          gesture=isOpen ? "open(explode)" : "open-ish(repel)";
        }

        if(isOpen){
          const now=performance.now();
          if(now-lastExplodeAt>650){
            explosion=1.0;
            lastExplodeAt=now;
          }
        }
      });

      // 用 camera_utils 驱动帧
      mpCamera = new Camera(video, {
        onFrame: async () => {
          // 节流一点，iPad 更稳
          if(!hands) return;
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });

      await mpCamera.start();
      addStatus("手势已启动：捏合吸引 / 张开爆炸");
    }

    btnCam.addEventListener("click", async ()=>{
      btnCam.disabled=true;
      try{
        await withTimeout(startCam(), 12000, "startCam");
        btnHands.disabled=false;
        setStatus("摄像头OK。你可以点“启动手势”，或直接进入画面用触控玩。");
      }catch(e){
        console.error(e);
        setStatus("摄像头启动失败：" + (e?.message || e));
        btnCam.disabled=false;
      }
    });

    btnHands.addEventListener("click", async ()=>{
      btnHands.disabled=true;
      try{
        if(!video.srcObject) await startCam();
        await withTimeout(initHands(), 20000, "initHands");
        setStatus("手势OK：捏合吸引 / 张开爆炸");
      }catch(e){
        console.error(e);
        setStatus("手势启动失败：" + (e?.message || e) + "\n（你仍可用触控玩；如果必须开VPN，换个更稳的节点）");
        btnHands.disabled=false;
      }
    });

    // ---------- Physics ----------
    function step(system, modeStrength){
      const {pos, vel, rest, geom} = system;
      const px=pointerWorld.x, py=pointerWorld.y, pz=0;
      const R=10.8, R2=R*R;
      const SPRING=0.0046, DAMP=0.985, WANDER=0.00055;

      for(let i=0;i<pos.length;i+=3){
        const x=pos[i], y=pos[i+1], z=pos[i+2];
        let vx=vel[i]*DAMP+(rest[i]-x)*SPRING;
        let vy=vel[i+1]*DAMP+(rest[i+1]-y)*SPRING;
        let vz=vel[i+2]*DAMP+(rest[i+2]-z)*SPRING;

        vx += (Math.random()-0.5)*WANDER;
        vy += (Math.random()-0.5)*WANDER;
        vz += (Math.random()-0.5)*WANDER;

        const dx=x-px, dy=y-py, dz=z-pz;
        const d2=dx*dx+dy*dy+dz*dz+1e-6;

        if(d2<R2){
          const d=Math.sqrt(d2);
          const falloff=(1-d/R);

          const repel=0.070*falloff*modeStrength;
          const attract=0.100*falloff*modeStrength;

          if(mouseDown){
            vx += (-dx/d)*attract; vy += (-dy/d)*attract; vz += (-dz/d)*attract;
          }else{
            vx += (dx/d)*repel;    vy += (dy/d)*repel;    vz += (dz/d)*repel;
          }

          if(explosion>0){
            const boom=(0.24*falloff)*explosion;
            vx += (dx/d)*boom; vy += (dy/d)*boom; vz += (dz/d)*boom;
          }
        }

        pos[i]=x+vx; pos[i+1]=y+vy; pos[i+2]=z+vz;
        vel[i]=vx; vel[i+1]=vy; vel[i+2]=vz;
      }
      geom.attributes.position.needsUpdate=true;
    }

    // snow move
    function stepSnow(sys){
      const {pos, vel, geom} = sys;
      for(let i=0;i<pos.length;i+=3){
        pos[i+1] += vel[i+1];
        pos[i]   += Math.sin((pos[i+1]+i)*0.002)*0.01;
        if(pos[i+1] < -10){
          pos[i+1] = rand(55, 15);
          pos[i] = rand(60, -60);
          pos[i+2] = rand(50, -50);
        }
      }
      geom.attributes.position.needsUpdate=true;
    }

    // ---------- Loop ----------
    let t0=performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      updatePointerWorld();

      explosion = Math.max(0, explosion - 0.035);

      const dt=Math.min(0.05,(now-t0)/1000);
      t0=now;

      // 微旋转 + 星芒呼吸
      main.pts.rotation.y += dt*0.10;
      ribbon.pts.rotation.y += dt*0.14;
      bells.pts.rotation.y += dt*0.08;
      glow.material.opacity = 0.75 + Math.sin(now*0.004)*0.20;

      step(main, 1.00);
      step(ribbon, 1.10);
      step(bells, 0.85);
      stepSnow(snow);

      hud.textContent =
`输入: ${usingHands ? "摄像头手势" : "触控/鼠标"}
手势: ${gesture}
pinch: ${Number.isFinite(pinch) ? pinch.toFixed(3) : "-"}
open : ${openScore.toFixed(3)}
爆炸: ${(explosion*100).toFixed(0)}%`;

      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    addEventListener("resize", ()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    });

    setStatus("页面已运行：先点“启动摄像头”。如果手势失败，状态框会说是脚本源失败还是权限失败。");
  </script>
</body>
</html>
